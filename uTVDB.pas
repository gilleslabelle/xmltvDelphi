{ ******************************************************* }
{ *
  {* uTVDB.pas
  {* Delphi Implementation of the Class TVDB
  {* Generated by Enterprise Architect
  {* Created on:      09-févr.-2015 11:49:22
  {* Original author: bvidovic
  {*
  {******************************************************* }

unit uTVDB;

interface

uses uEpisode, uTVDBMatcher, uTVDBSeries, System.Generics.Collections, CodeSiteLogging;

type

  TTVDB = class
  private const

//    UNCOMMON_CHAR_ARRAY: array [1 .. 26] of char = ('<', '>', ':', '"', '/', '\', '|', '?', '*', '#', '$', '%', '^',
//      '*', '!', '~', '\', '’', '=', '[', ']', '(', ')', ';', ',', '_');

    UNCOMMON_CHAR_ARRAY2: Set of char = ['<', '>', ':', '"', '/', '\', '|', '?', '*', '#', '$', '%', '^', '*', '!', '~',
      '\', '’', '=', '[', ']', '(', ')', ';', ',', '_'];

  strict private
    // UNCOMMON_CHARS: Tlist<char>;

    Fe: IEpisode;
    Fserieses: TTVDBSeriesColl;

    // function findMatchingSeries: TTVDBSeriesColl;
    function getMatches(series: TTVDBSeries): TTVDBMatcher;
    procedure findMatchingSeries(out resultat: TTVDBSeriesColl);
  public

    class function cleanCommonWords(s: String): String;
    class function cleanParenthesis(s: String): String;
    class function dateToTVDBString(d: TDateTime): String;
    class function fuzzyTitleMatch(source: String; test: String; percentDiscrepencyAllowed: Integer): boolean;
    class function getLevenshteinDistance(s: String; t: String): Integer;
    function lookup: boolean;
    class function normalize(s: String): String;
    constructor Create(const e: IEpisode); overload;
    // ###if no series, no lookup###
    //
    // Lookups from best to worst:
    // ---------------------------------------
    // exact title & original airdate (check for multipart?)
    // fuzzy title & original air date (check for multipart)
    // contains title & original air date (check for multipart)
    // exact title (must be a solo match)
    // original airdate (must be a solo match)
    // fuzzy title (must be a solo match)
    // contains title (must be a solo match)
    //
    // checking for multiparts:
    // multipart means that a single airing in the guide XML maps to 2 or more seperate entries on thetvdb.com
    // The original air date for all tvdb entries must be the same
    // The titles must either match fuzzy or match contains.
    ///

    destructor Destroy; override;
  end;

implementation

uses
  System.SysUtils, uMatch, System.Math, REST.Utils, uMatchAccuracy,
  uTVDBEpisode, uConts, Xml.XMLIntf,
  Xml.XMLDoc, uTVDBBind, System.DateUtils, HTTPApp, System.Variants, IdHTTP,
  System.Classes, uDataModule,System.NetEncoding ;

{ implementation of TVDB }

destructor TTVDB.Destroy;
begin
  Fserieses.Free;
  inherited Destroy;

end;

class function TTVDB.cleanCommonWords(s: String): String;
const
  articles: array [1 .. 8] of string = ('the', 'a', 'an', 'The', 'A', 'An', 'part', 'Part');
var
  article: string;
begin
  if (s = '') then
  begin
    Result := s;
  end
  else
  begin
    for article in articles do
    begin
      s := s.replace(' ' + article + ' ', ' ');
      s := s.replace(' ' + article, ' ');
      s := s.replace(article + ' ', ' ');
      s := s.replace('  ', ' '); // catch any double spaces

    end;
    Result := s;
  end;
end;

class function TTVDB.cleanParenthesis(s: String): String;
begin
  { TODO : Code à Completer }
  // Pattern p = Pattern.compile("[\\(].*[\\)]");///catch any characters inside of (...)
  // Matcher m = p.matcher(s);
  // while(m.find())
  // {
  // s = s.replace(m.group(), "");
  // }
  // return s;
  Result := s;
end;

function URLEncode(const s: string): string;
begin
//  Result := HTTPEncode(s);
  Result := TNetEncoding.URL.Encode(s);
end;

constructor TTVDB.Create(const e: IEpisode);
begin
  inherited Create;


  self.Fe := e;

  // UNCOMMON_CHARS := Tlist<char>.Create;
  // UNCOMMON_CHARS.AddRange(UNCOMMON_CHAR_ARRAY);

  Fserieses := TTVDBSeriesColl.Create;

  if e = nil then
  begin
    raise Exception.Create('No episode found to look up.');
  end;

  if not e.hasSeries then
  begin

    raise Exception.Create('No series name found.');
  end;

  // get the series from tvdb based on series name and language
  findMatchingSeries(Fserieses); // populates seriesIds
  if (Fserieses.Count = 0) then
  begin
    // raise Exception.Create('No series found on TVDB.com for series name \' + e.getSeries.toString + '\');
  end;

end;

class function TTVDB.dateToTVDBString(d: TDateTime): String;
begin

  Result := FormatDateTime('yyyy-mm-dd', d);
end;

procedure TTVDB.findMatchingSeries(out resultat: TTVDBSeriesColl);
var
  // ids: TTVDBSeriesColl;
  maxSeries: Integer;
  seriesName: string;
  tvdbURL: string;
  doc: IXMLDocument;
  Xml: IXMLTVDBDataType;
//  children: string;
  I: Integer;
  seriesCount: Integer;
  series: IXMLTVDBSeriesType;
  seriesId: string;
  nextSeries: TTVDBSeries;
  Entry: TPair<String, String>;
  remoteProvider: string;
  remoteId: string;
  remoteIds :TDictionary<String, String>;
begin
  // ids := TTVDBSeriesColl.Create;

   remoteIds :=TDictionary<String, String>.Create;
   try


  if (Fe.hasTVDBid()) then
  begin
    resultat.add(TTVDBSeries.Create(Fe.getTVDBId())); // we alrady know the series id
    CodeSite.SendMsg('TheTVDB series ID is overridden in config file, no need to look it up. Using ID of: ' +
      Fe.getTVDBId);
    // Result := ids;
    exit;
  end;

  // remote id provided from schedulesdirect/zap2it or imdb
  if (Fe.hasRemoteId()) then
  begin
     Fe.getRemoteIds(remoteIds);
    for Entry in remoteIds do
    begin

      remoteProvider := Entry.Key;
      remoteId := Entry.Value;

      tvdbURL := 'http://www.thetvdb.com/api/GetSeriesByRemoteID.php?' + remoteProvider + '=' + URLEncode(remoteId) +
        '&language=' + Fe.getLanguage;

      doc := TXMLDocument.Create(nil);
      doc.LoadFromFile(tvdbURL);

      Xml := uTVDBBind.GetData(doc);

      if (Xml <> nil) then
      begin

        if Xml.series.Count = 0 then
        begin
          CodeSite.SendWarning('No tvdb series id found for ' + remoteProvider + ' ' + remoteId);
          // will do a search

        end
        else // only returns 1 series
        begin
          series := Xml.series[0]; // children.get(0);

          seriesId := series.seriesId; // .getChildText('seriesid');
          resultat.add(TTVDBSeries.Create(seriesId));
          seriesName := series.seriesName; // .getChildText('SeriesName');
          CodeSite.SendMsg('Found TVDB series using ' + remoteProvider + ' ' + remoteId + ': seriesName= ' + seriesName
            + ' tvdbid = ' + seriesId);
          // return ids;
          exit;
        end;
      end;
    end;
  end;

  if (Fe.hasRemoteId()) then
  begin // if got here, we did not successfully lookup based on remote id. Remove it since it's not useful to us
    Fe.clearRemoteIds();
  end;

  // if got here no id specified or remote id lookup failed, lookup based on series name
  maxSeries := 5; // FConfig.MAX_TVDB_SERIES_LOOKUP;
  seriesName := Fe.getSeries().seriesName;
  tvdbURL := 'http://www.thetvdb.com/api/GetSeries.php?seriesname=' + URLEncode(seriesName) + '&language=' +
    Fe.getLanguage;
  CodeSite.SendMsg('Attempting to get series ID (max of ' + maxSeries.ToString + ') based on seriesname of ' +
    seriesName + ', url = ' + tvdbURL);

  doc := TXMLDocument.Create(nil);
  doc.LoadFromFile(tvdbURL);

  Xml := uTVDBBind.GetData(doc);

  // Document xml = HTTP.getXMLFromURL(tvdbURL);
  if (Xml <> nil) then
  begin
    // children := xml.Series.SeriesID;

    // List<Element> children = xml.getRootElement().getChildren();
    seriesCount := 0;
    for I := 0 to Xml.series.Count - 1 do
    begin
      series := Xml.series[I];

      seriesId := series.seriesId;
      // seriesId := IntToStr(series.Id);// .getChildText('seriesid');
      seriesName := series.seriesName; // .getChildText('SeriesName');
      nextSeries := TTVDBSeries.Create(seriesId, seriesName, '');
      if (resultat.contains(nextSeries)) then
        continue; // dont want dups

      resultat.add(nextSeries);
      inc(seriesCount);
      // CodeSite.SendMsg( 'Adding Series #'+seriesCount.ToString+' found from thetvdb: seriesName= ' + seriesName + '\' + tvdbid = '' + seriesId+);

      if (seriesCount = maxSeries) then
        break; // limit
    end;

  end;

  if (resultat.Count = 0) then
  begin
    CodeSite.SendWarning('No series could be found by querying TheTVDB.com for series named ' + Fe.getSeries.ToString);
  end;

   finally
     remoteIds.Free;

   end;
  // Result := ids;

end;

class function TTVDB.fuzzyTitleMatch(source: String; test: String; percentDiscrepencyAllowed: Integer): boolean;
var
  difference: Integer;
  fuzzyMatchMaxDifferent: Integer;
begin

  if ((source = '') or (test = '')) then
  begin

    Result := False;
    exit;
  end;

  // clean out articles and anything in parenthesis
  source := cleanCommonWords(cleanParenthesis(source.ToLower));
  test := cleanCommonWords(cleanParenthesis(test.ToLower));
  if (percentDiscrepencyAllowed > 100) then
    percentDiscrepencyAllowed := 100;

  fuzzyMatchMaxDifferent := Trunc(source.length / (100 / percentDiscrepencyAllowed)); // allow x% discrepency
  if (fuzzyMatchMaxDifferent <= 0) then
    fuzzyMatchMaxDifferent := 1; // allow at least 1 char diff

  difference := getLevenshteinDistance(source, test);
  Result := (difference <= fuzzyMatchMaxDifferent);

end;

class function TTVDB.getLevenshteinDistance(s: String; t: String): Integer;
var
  d: array of array of Integer;
  I, j, cost: Integer;
begin

  // initialize our cost array
  SetLength(d, length(s) + 1);
  for I := Low(d) to High(d) do
  begin
    SetLength(d[I], length(t) + 1);
  end;

  for I := Low(d) to High(d) do
  begin
    d[I, 0] := I;
    for j := Low(d[I]) to High(d[I]) do
    begin
      d[0, j] := j;
    end;
  end;

  // store our costs in a 2-d grid
  for I := Low(d) + 1 to High(d) do
  begin
    for j := Low(d[I]) + 1 to High(d[I]) do
    begin
      if s[I] = t[j] then
      begin
        cost := 0;
      end
      else
      begin
        cost := 1;
      end;

      // to use "Min", add "Math" to your uses clause!
      d[I, j] := Min(Min(d[I - 1, j] + 1, // deletion
        d[I, j - 1] + 1), // insertion
        d[I - 1, j - 1] + cost // substitution
        );
    end; // for j
  end; // for i

  // now that we've stored the costs, return the final one
  Result := d[length(s), length(t)];

  // dynamic arrays are reference counted.
  // no need to deallocate them

end;

function TTVDB.getMatches(series: TTVDBSeries): TTVDBMatcher;
var
  Xml: IXMLTVDBDataType;

  tvdbURL: string;
//  doc: IXMLDocument;
  // seriesElem: IXMLTVDBSeriesType;
  firstAired: string;
  episodes: IXMLTVDBEpisodeTypeList;
  matches: TTVDBMatcher;
  seriesElem: IXMLTVDBSeriesTypeList;
//  objHttp: TIdHTTP;
  ms: TStringStream;
begin

  // doc:= TXMLDocument.Create(self);
  // doc.LoadFromFile('http://thetvdb.com/api/9A0AE5E0CA9135DC/series/83620/all/fr.xml');
  //
  /// /doc.LoadFromFile('http://thetvdb.com/api/GetSeries.php?seriesname=Infoman&language=fr');
  //
  /// /doc.LoadFromFile('http://thetvdb.com/api/GetSeriesByRemoteID.php?language=fr&zap2it=SH0040080500');
  //
  //
  // if doc=nil then
  // exit;
  //
  // qq:=  fr.GetData(doc);
  //
  // seriename:=  qq.Series.SeriesName;
  // episodes:=  qq.Episode;
  //
  // serieid:=qq.Series.Id;
  // for I := 0 to episodes.Count-1 do
  // begin
  // episodename := episodes[i].EpisodeName;
  // end;
  //
  //
  // end;
  //

  // doc := TXMLDocument.Create(nil);


  // look for matches on title & original air date
  // tvdbURL := 'http://www.thetvdb.com/api/' + TVDB_API_KEY + '/series/'+series.seriesId+'/all/'+ Fe.getLanguage+'.zip';
  tvdbURL := 'http://www.thetvdb.com/api/' + TVDB_API_KEY + '/series/' + series.seriesId + '/all/' +
    Fe.getLanguage + '.xml';



  ms := TStringStream.Create;
  try
//   if  DataModuleMain.GetXmlDocument(tvdbURL, ms,Fe.getLanguage + '.xml' ) then
  if DataModuleMain.GetXmlDocument(tvdbURL, ms) then
  begin
    DataModuleMain.XMLDocument1.LoadFromStream(ms, TXMLEncodingType.xetUTF_8);
    Xml := uTVDBBind.GetData(DataModuleMain.XMLDocument1); // doc);
  end;



  if Xml = nil then
  begin

    Result := nil
  end
  else
  begin

    seriesElem := Xml.series;
    series.seriesName := seriesElem[0].seriesName; // .getChildText('SeriesName');

    CodeSite.SendMsg('Getting episodes for series: ' + series.seriesName);

    // parse the year this series was first aired
    firstAired := seriesElem[0].firstAired; // . getChildText('FirstAired');//2011-10-23
    if (firstAired <> '') then
    begin

      series.seriesYear := YearOf(vartoDateTime(firstAired)).ToString;
      // trybegin
      // String[] parts = firstAired.split('-');
      // if(parts.length != 3)
      // throw new Exception('Unkown aired date, expected yyyy-mm-dd, found: '+ firstAired);
      //
      // String year = parts[0];
      // if(year.length() != 4)
      // throw new Exception('Unknown year: '+ year);
      //
      // series.seriesYear = year;
      // end;catch(Exception x)
      // begin
      // codesite.WARN( 'Could not parse year from date: '+ firstAired);
      // end;
    end;

    episodes := Xml.Episode;

    // List <Element> episodes = xml.getRootElement().getChildren('Episode');

    if (episodes = nil) then // || episodes.isEmpty())
    begin
      CodeSite.SendWarning('No episodes found on TheTVDB for series: ' + series.ToString + '. ' +
        'You may need to add the series/episodes on TheTVDB.com, or manually provide the correct TVDB id in the config file.');
      Result := nil;
    end
    else
    begin
      CodeSite.SendMsg('Will search ' + episodes.Count.ToString + ' episodes for a match.');
    end;

    CodeSite.Send('Found ' + episodes.Count.ToString + ' episodes for series: ' + series.ToString);
    matches := TTVDBMatcher.Create(Fe, episodes);
    Result := matches;

//    CodeSite.AddSeparator;


  end;
  finally
    ms.Free;
  end;
end;

function TTVDB.lookup: boolean;
var
  matches: TMatchColl;
  // tvdbMatch: TVDBMatcher;
  series: TTVDBSeries;
  tvdbMatch: TTVDBMatcher;
  ep: ITVDBEpisode;
  dateStr: string;
  m: TMatch;
  bestMatch: TMatch;
  // unMatch: Match;
begin

  matches := TMatchColl.Create;


  for series in Fserieses do
  begin
    // String seriesId = entry.getKey();
    tvdbMatch := getMatches(series);

    if (tvdbMatch = nil) then
      continue;
     CodeSite.SendMsg(csmLevel7,'TVDB Matches Found (title=' + Fe.getTitle + ', airdate=' + iif(Fe.hasOriginalAirDate,
     dateToTVDBString(Fe.getOriginalAirDate),'unknown'));
//     FormatDateTime('yyyymmdd', Fe.getOriginalAirDate), 'unknown'));
    // CodeSite.SendMsg('originalAirDateMatches: ' + tvdbMatch.originalAirDateMatches.ToString);
    // CodeSite.SendMsg('exactTitleMatches:      ' + tvdbMatch.exactTitleMatches.ToString);
    // CodeSite.SendMsg('fuzzyTitleMatches:      ' + tvdbMatch.fuzzyTitleMatches.ToString);
    // CodeSite.SendMsg('containsTitleMatches:   ' + tvdbMatch.containsTitleMatches.ToString);

    // check air date + title matches
    if not(tvdbMatch.originalAirDateMatches.Count = 0) then // original airdate had some some matches
    begin
      // exact title & date
      if not(tvdbMatch.exactTitleMatches.Count = 0) then
      begin

        if (tvdbMatch.originalAirDateMatches.containsAll(tvdbMatch.exactTitleMatches)) then
        begin

          matches.add(TMatch.Create(TMatchAccuracy.ORIGINAL_AIR_DATE_AND_EXACT_TITLE, series,
            tvdbMatch.exactTitleMatches));
          break; // exact match, we can break now
        end;
      end;

      // fuzzytitle & date
      if (tvdbMatch.fuzzyTitleMatches.containsAll(tvdbMatch.originalAirDateMatches)) then
      begin

        matches.add(TMatch.Create(TMatchAccuracy.ORIGINAL_AIR_DATE_AND_FUZZY_TITLE, series,
          tvdbMatch.originalAirDateMatches));
        break; // exact (enough) match, we can break now
      end;

      // contains title & date
      if (tvdbMatch.containsTitleMatches.containsAll(tvdbMatch.originalAirDateMatches)) then
      begin

        matches.add(TMatch.Create(TMatchAccuracy.ORIGINAL_AIR_DATE_AND_CONTAINS_TITLE, series,
          tvdbMatch.originalAirDateMatches));
        continue; // check next series too since this isn't a very exact match
      end
      else // check in opposite direction. Catches if multiple episodes have same original air date, but needs to be filtered down to this episode
      begin
        if (tvdbMatch.containsTitleMatches.Count <> 0) then
        begin
          if (tvdbMatch.originalAirDateMatches.containsAll(tvdbMatch.containsTitleMatches)) then
          begin

            matches.add(TMatch.Create(TMatchAccuracy.ORIGINAL_AIR_DATE_AND_CONTAINS_TITLE, series,
              tvdbMatch.containsTitleMatches));
            continue; // check next series too since this isn't very exact match
          end;
        end;
      end;
    end; // done with date combo matches


    // if we got here, there are no air date/combo matches. Check for title matches, but don't allow multi
    // part for those because we can't verify they aired on the same date.

    // exact title, solo match
    if (tvdbMatch.exactTitleMatches.Count = 1) then
    begin
      CodeSite.SendMsg(csmLevel7,'Found Exact title match: ' + tvdbMatch.exactTitleMatches.ToString);
      matches.add(TMatch.Create(TMatchAccuracy.EXACT_TITLE, series, tvdbMatch.exactTitleMatches));
      break; // exact enough, break here
    end
    else if (tvdbMatch.exactTitleMatches.Count > 1) then
    begin
      CodeSite.SendWarning('Found ' + tvdbMatch.exactTitleMatches.Count.ToString +   ' exact title matches! Don''t know what one to use!');
    end;

    // original airdate, solo/multi match
    if (tvdbMatch.originalAirDateMatches.Count <> 0) then
    begin
      // allow multi match for original air date
      matches.add(TMatch.Create(TMatchAccuracy.ORIGINAL_AIR_DATE, series, tvdbMatch.originalAirDateMatches));
      continue;
    end;

    // fuzzy title, solo match
    if (tvdbMatch.fuzzyTitleMatches.Count = 1) then
    begin
      matches.add(TMatch.Create(TMatchAccuracy.FUZZY_TITLE, series, tvdbMatch.fuzzyTitleMatches));
      continue;
    end
    else if (tvdbMatch.fuzzyTitleMatches.Count > 1) then
      CodeSite.SendMsg(csmLevel7,'Found ' + tvdbMatch.fuzzyTitleMatches.Count.ToString +   ' fuzzy title matches! Don''t know what one to use!');

    // contains title, solo match
    if (tvdbMatch.containsTitleMatches.Count = 1) then
    begin
      matches.add(TMatch.Create(TMatchAccuracy.CONTAINS_TITLE, series, tvdbMatch.containsTitleMatches));
      continue;
    end;

    // allow multi-contains if the air date is all the same
    if (tvdbMatch.containsTitleMatches.Count > 1) then
    begin
      CodeSite.SendMsg(csmLevel7,'Found multiple contains-title matches, determining if all have same original air date.');
      dateStr := ''; // = null;
      for ep in tvdbMatch.containsTitleMatches do
      begin
        if (ep.GetfirstAired = '') then
        begin // no valid date from tvdb... can't check this
          dateStr := '';
          break;
        end;

        if (dateStr = '') then
        begin
          dateStr := ep.GetfirstAired; // init
        end
        else if (not dateStr.equals(ep.GetfirstAired)) then
        begin
          dateStr := ''; // signals invalid because they dont all have the same date
          break;
        end;
      end;
      if (dateStr <> '') then // same date for all episodes
      begin
        CodeSite.SendMsg(csmLevel7,'All contains-title matches have same original air date, will add as a multi-part episode');
        matches.add(TMatch.Create(TMatchAccuracy.CONTAINS_TITLE, series, tvdbMatch.containsTitleMatches));
      end
      else
      begin
        CodeSite.SendMsg(csmLevel7,'Contains-title matches have different air-dates, cannot determine what episode to use.');
      end;
    end;
  end; // end looping through all series and finding matches

  if (matches.Count <> 0) then
  begin
    CodeSite.SendMsg(csmLevel7,'Found ' + matches.Count.ToString + ' TVDB.com match' + iif(matches.Count = 1, ', will use it',
      'es, will use best one'));
    matches.Sort; // best matches (most accurate) are on top now
    // Collections.sort(matches);

    // print all matches
    for m in matches do
    begin
      // CodeSite.SendWarning( 'Match - Series: '+ m.series.toString+': '+ m.accuracy.tostring +' for '+ m.matchingEpisodes.Count +' episode(s):');

       CodeSite.SendMsg( 'Match - Series: '+ m.series.toString+': '+ m.accuracy.ToString +' for '+ m.matchingEpisodes.Count.ToString +' episode(s):');


      // CodeSite.SendWarning(m.matchingEpisodes.ToString);
    end;

    // use the first (best) match
    bestMatch := matches[0];

    Fe.setSeries(bestMatch.series);
    if (bestMatch.matchingEpisodes.Count > 1) then // log if multiple episodes
    begin
      CodeSite.SendMsg(csmLevel7,'Multi-Part: Setting matching episodes to: ' + bestMatch.matchingEpisodes.ToString);
    end;

    Fe.setMatchingEpisodes(bestMatch.matchingEpisodes);
    Result := true;
    exit;
  end
  else
  begin
    if (Fe.hasRemoteId) then // maybe the remote id is wrong, try it based on series name
    begin

      CodeSite.SendMsg(csmLevel7,'No match was found using exernal id(s), will try lookup based on series name now.');
//      CodeSite.SendMsg(csmLevel7,'No match was found using exernal id(s) (' + Fe.getRemoteIds().values.ToString +
//        '), will try lookup based on series name now.');
      Fe.clearRemoteIds();

      findMatchingSeries(Fserieses);

      Result := lookup(); // recurse using the new seriesIds

      exit;
    end
    else // no match
    begin
      CodeSite.SendWarning('Found no matches!');
      Result := False;
      exit;
    end;
  end;

end;

class function TTVDB.normalize(s: String): String;
var
  normal: string;
  I: Integer;
  c: char;
begin
  if (s = '') then
  begin
    Result := '';

  end
  else
  begin
    normal := '';
    for I := 0 to s.length - 1 do
    begin
      c := s.Chars[I]; // s.charAt(i);
      if (c = '/') then
        c := ' ' // replace slash with a space

        // UNCOMMON_CHAR_ARRAY
        // UNCOMMON_CHAR_ARRAY
      else if not(c in UNCOMMON_CHAR_ARRAY2) then // noy uncommon
        normal := normal + c;
    end;
    Result := normal;
  end;
end;

end.
