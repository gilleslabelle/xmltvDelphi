{ ******************************************************* }
{ *
  {* uTVDB.pas
  {* Delphi Implementation of the Class TVDB
  {* Generated by Enterprise Architect
  {* Created on:      09-févr.-2015 11:49:22
  {* Original author: bvidovic
  {*
  {******************************************************* }

unit xmltvdb.tvdb;

interface

uses System.Generics.Collections, CodeSiteLogging, xmltvdb.Episode,System.RegularExpressions ,
  xmltvdb.TVDBSeries, xmltvdb.TVDBMatcher;

type

  TTVGeneral=class
   strict private const

    UNCOMMON_CHAR_ARRAY2: Set of Ansichar = ['<', '>', ':', '"', '/', '\', '|', '?', '*', '#', '$', '%', '^', '*', '!', '~',
      '\', '’', '=', '[', ']', '(', ')', ';', ',', '_'];
  public
    class function cleanCommonWords(s: String): String;
    class function cleanParenthesis(s: String): String;
    class function dateToTVDBString(d: TDateTime): String;
    class function fuzzyTitleMatch(source: String; test: String; percentDiscrepencyAllowed: Integer): boolean;
    class function getLevenshteinDistance(s: String; t: String): Integer;
    class function normalize(s: String): String;

  end;

  TTVDB = class
  strict private

    Fe:        IEpisode;
    Fserieses: TTVDBSeriesColl;

    procedure getMatches(series: ITVDBSeries; out resultat: ITVDBMatcher);
    procedure findMatchingSeries(out resultat: TTVDBSeriesColl);
  public

    function lookup: boolean;
    constructor Create(var e: IEpisode); overload;
    destructor Destroy; override;
    // ###if no series, no lookup###
    //
    // Lookups from best to worst:
    // ---------------------------------------
    // exact title & original airdate (check for multipart?)
    // fuzzy title & original air date (check for multipart)
    // contains title & original air date (check for multipart)
    // exact title (must be a solo match)
    // original airdate (must be a solo match)
    // fuzzy title (must be a solo match)
    // contains title (must be a solo match)
    //
    // checking for multiparts:
    // multipart means that a single airing in the guide XML maps to 2 or more seperate entries on thetvdb.com
    // The original air date for all tvdb entries must be the same
    // The titles must either match fuzzy or match contains.
    ///

  end;

  TTVGracenote = class
  strict private

    Fe:        IEpisode;
    Fserieses: TTVDBSeriesColl;

//    procedure getMatches(series: ITVDBSeries; out resultat: ITVDBMatcher);
    procedure findMatchingSeries(out resultat: TTVDBSeriesColl);
  public
    function lookup: boolean;
    constructor Create(var e: IEpisode); overload;
    destructor Destroy; override;

  end;


  var
  FRegEx: TRegEx;

implementation

uses
  System.SysUtils, System.Math, REST.Utils, uConts, Xml.XMLIntf,
  Xml.XMLDoc, uTVDBBind, System.DateUtils, HTTPApp, System.Variants, IdHTTP,
  System.Classes, uDataModule, System.NetEncoding, xmltvdb.Match,
  xmltvdb.TVDBEpisode, xmltvdb.MatchAccuracy;

{ implementation of TVDB }

destructor TTVDB.Destroy;
begin
  Fserieses.Free;
  inherited Destroy;

end;

class function TTVGeneral.cleanCommonWords(s: String): String;
const
  articles: array [1 .. 8] of string = ('the', 'a', 'an', 'The', 'A', 'An', 'part', 'Part');
var
  article: string;
begin
  if (s = '') then
  begin
    Result := s;
  end
  else
  begin
    for article in articles do
    begin
      s := s.replace(' ' + article + ' ', ' ');
      s := s.replace(' ' + article, ' ');
      s := s.replace(article + ' ', ' ');
      s := s.replace('  ', ' '); // catch any double spaces

    end;
    Result := s;
  end;
end;

class function TTVGeneral.cleanParenthesis(s: String): String;
var
  RegEx: TRegEx;

  m:TMatchCollection;
  unMath: system.RegularExpressions.TMatch;
begin

  RegEx:= TRegEx.Create('[\\(].*[\\)]');
  try
     m:= RegEx.Matches(s);

      for unMath in m do
      begin
          s:= s.Replace(unMath.Groups[0].Value,'');
      end;

  finally
  Result := s;

  end;
  { TODO : Code à Completer }
  // Pattern p = Pattern.compile("[\\(].*[\\)]");///catch any characters inside of (...)
  // Matcher m = p.matcher(s);
  // while(m.find())
  // {
  // s = s.replace(m.group(), "");
  // }

end;

function URLEncode(const s: string): string;
begin
  // Result := HTTPEncode(s);
  Result := TNetEncoding.URL.Encode(s);
end;

constructor TTVDB.Create(var e: IEpisode);
begin
  inherited Create;

  self.Fe := e;


  Fserieses := TTVDBSeriesColl.Create;

  if e = nil then
  begin
    raise Exception.Create('No episode found to look up.');
  end;

  if not e.hasSeries then
  begin

    raise Exception.Create('No series name found.');
  end;

  // get the series from tvdb based on series name and language
  findMatchingSeries(Fserieses); // populates seriesIds
  if (Fserieses.Count = 0) then
  begin
    // raise Exception.Create('No series found on TVDB.com for series name \' + e.getSeries.toString + '\');
  end;

end;

class function TTVGeneral.dateToTVDBString(d: TDateTime): String;
begin

  Result := FormatDateTime('yyyy-mm-dd', d);
end;

procedure TTVDB.findMatchingSeries(out resultat: TTVDBSeriesColl);
var
  maxSeries:  Integer;
  seriesName: string;
  tvdbURL:    string;
  doc:        IXMLDocument;
  Xml:        IXMLTVDBDataType;
  I:              Integer;
  seriesCount:    Integer;
  series:         IXMLTVDBSeriesType;
  seriesId:       string;
  nextSeries:     ITVDBSeries;
  Entry:          TPair<String, String>;
  remoteProvider: string;
  remoteId:       string;
  remoteIds:      TDictionary<String, String>;
begin


  remoteIds := TDictionary<String, String>.Create;
  try

    if (Fe.hasTVDBid()) then
    begin
      resultat.add(TTVDBSeries.Create(Fe.getTVDBId())); // we alrady know the series id
      CodeSite.SendMsg('TheTVDB series ID is overridden in config file, no need to look it up. Using ID of: ' +
        Fe.getTVDBId);

      exit;
    end;

    // remote id provided from schedulesdirect/zap2it or imdb
    if (Fe.hasRemoteId()) then
    begin
      Fe.getRemoteIds(remoteIds);
      for Entry in remoteIds do
      begin

        remoteProvider := Entry.Key;
        remoteId       := Entry.Value;

        tvdbURL := 'http://www.thetvdb.com/api/GetSeriesByRemoteID.php?' + remoteProvider + '=' + URLEncode(remoteId) +
          '&language=' + Fe.getLanguage;

        doc := TXMLDocument.Create(nil);
        doc.LoadFromFile(tvdbURL);

        Xml := uTVDBBind.GetData(doc);

        if (Xml <> nil) then
        begin

          if Xml.series.Count = 0 then
          begin
            CodeSite.SendWarning('No tvdb series id found for ' + remoteProvider + ' ' + remoteId);
            // will do a search

          end
          else // only returns 1 series
          begin
            series := Xml.series[0]; // children.get(0);

            seriesId := series.seriesId; // .getChildText('seriesid');
            resultat.add(TTVDBSeries.Create(seriesId));
            seriesName := series.seriesName; // .getChildText('SeriesName');
            CodeSite.SendMsg('Found TVDB series using ' + remoteProvider + ' ' + remoteId + ': seriesName= ' +
              seriesName + ' tvdbid = ' + seriesId);
            // return ids;
            exit;
          end;
        end;
      end;
    end;

    if (Fe.hasRemoteId()) then
    begin // if got here, we did not successfully lookup based on remote id. Remove it since it's not useful to us
      Fe.clearRemoteIds();
    end;

    // if got here no id specified or remote id lookup failed, lookup based on series name
    maxSeries  := 5; // FConfig.MAX_TVDB_SERIES_LOOKUP;
    seriesName := Fe.getSeries().GetseriesName;
    tvdbURL    := 'http://www.thetvdb.com/api/GetSeries.php?seriesname=' + URLEncode(seriesName) + '&language=' +
      Fe.getLanguage;
    CodeSite.SendMsg('Attempting to get series ID (max of ' + maxSeries.ToString + ') based on seriesname of ' +
      seriesName + ', url = ' + tvdbURL);

    doc := TXMLDocument.Create(nil);
    doc.LoadFromFile(tvdbURL);

    Xml := uTVDBBind.GetData(doc);

    // Document xml = HTTP.getXMLFromURL(tvdbURL);
    if (Xml <> nil) then
    begin
      // children := xml.Series.SeriesID;

      // List<Element> children = xml.getRootElement().getChildren();
      seriesCount := 0;
      for I       := 0 to Xml.series.Count - 1 do
      begin
        series := Xml.series[I];

        seriesId := series.seriesId;
        // seriesId := IntToStr(series.Id);// .getChildText('seriesid');
        seriesName := series.seriesName; // .getChildText('SeriesName');
        nextSeries := TTVDBSeries.Create(seriesId, seriesName, '');
        if (resultat.contains(nextSeries)) then
          continue; // dont want dups

        resultat.add(nextSeries);
        inc(seriesCount);
        // CodeSite.SendMsg( 'Adding Series #'+seriesCount.ToString+' found from thetvdb: seriesName= ' + seriesName + '\' + tvdbid = '' + seriesId+);

        if (seriesCount = maxSeries) then
          break; // limit
      end;

    end;

    if (resultat.Count = 0) then
    begin
      CodeSite.SendWarning('No series could be found by querying TheTVDB.com for series named ' +
        Fe.getSeries.ToString);
    end;

  finally
    remoteIds.Free;

  end;
  // Result := ids;

end;

class function TTVGeneral.fuzzyTitleMatch(source: String; test: String; percentDiscrepencyAllowed: Integer): boolean;
var
  difference:             Integer;
  fuzzyMatchMaxDifferent: Integer;
begin

  if ((source = '') or (test = '')) then
  begin

    Result := False;
    exit;
  end;

  // clean out articles and anything in parenthesis
  source := cleanCommonWords(cleanParenthesis(source.ToLower));
  test   := cleanCommonWords(cleanParenthesis(test.ToLower));
  if (percentDiscrepencyAllowed > 100) then
    percentDiscrepencyAllowed := 100;

  fuzzyMatchMaxDifferent := Trunc(source.length / (100 / percentDiscrepencyAllowed)); // allow x% discrepency
  if (fuzzyMatchMaxDifferent <= 0) then
    fuzzyMatchMaxDifferent := 1; // allow at least 1 char diff

  difference := getLevenshteinDistance(source, test);
  Result     := (difference <= fuzzyMatchMaxDifferent);

end;

class function TTVGeneral.getLevenshteinDistance(s: String; t: String): Integer;
var
  d:          array of array of Integer;
  I, j, cost: Integer;
begin

  // initialize our cost array
  SetLength(d, length(s) + 1);
  for I := Low(d) to High(d) do
  begin
    SetLength(d[I], length(t) + 1);
  end;

  for I := Low(d) to High(d) do
  begin
    d[I, 0] := I;
    for j   := Low(d[I]) to High(d[I]) do
    begin
      d[0, j] := j;
    end;
  end;

  // store our costs in a 2-d grid
  for I := Low(d) + 1 to High(d) do
  begin
    for j := Low(d[I]) + 1 to High(d[I]) do
    begin
      if s[I] = t[j] then
      begin
        cost := 0;
      end
      else
      begin
        cost := 1;
      end;

      // to use "Min", add "Math" to your uses clause!
      d[I, j] := Min(Min(d[I - 1, j] + 1, // deletion
        d[I, j - 1] + 1),                 // insertion
        d[I - 1, j - 1] + cost            // substitution
        );
    end; // for j
  end;   // for i

  // now that we've stored the costs, return the final one
  Result := d[length(s), length(t)];

  // dynamic arrays are reference counted.
  // no need to deallocate them

end;

procedure TTVDB.getMatches(series: ITVDBSeries; out resultat: ITVDBMatcher);
var
  Xml:        IXMLTVDBDataType;
  tvdbURL:    string;
  firstAired: string;
  episodes:   IXMLTVDBEpisodeTypeList;
 // matches:    ITVDBMatcher;
  seriesElem: IXMLTVDBSeriesTypeList;
  ms:         TStringStream;
begin

  // look for matches on title & original air date
  tvdbURL := 'http://www.thetvdb.com/api/' + TVDB_API_KEY + '/series/' + series.GetseriesId + '/all/' + Fe.getLanguage + '.xml';

  ms := TStringStream.Create;
  try
    if DataModuleMain.GetXmlDocument(tvdbURL, ms) then
    begin
      DataModuleMain.XMLDocument1.LoadFromStream(ms, TXMLEncodingType.xetUTF_8);
      Xml := uTVDBBind.GetData(DataModuleMain.XMLDocument1); // doc);
    end;

    if Xml = nil then
    begin
      resultat := nil
    end
    else
    begin

      seriesElem := Xml.series;
      series.SetseriesName(seriesElem[0].seriesName); // .getChildText('SeriesName');

      CodeSite.SendMsg('Getting episodes for series: ' + series.GetseriesName);

      // parse the year this series was first aired
      firstAired := seriesElem[0].firstAired; // . getChildText('FirstAired');//2011-10-23
      if (firstAired <> '') then
      begin
        series.SetseriesYear(YearOf(vartoDateTime(firstAired)).ToString);
      end;

      episodes := Xml.Episode;

      if (episodes = nil) then // || episodes.isEmpty())
      begin
        CodeSite.SendWarning('No episodes found on TheTVDB for series: ' + series.ToString + '. ' +
          'You may need to add the series/episodes on TheTVDB.com, or manually provide the correct TVDB id in the config file.');
        resultat := nil;
      end
      else
      begin
        CodeSite.SendMsg('Will search ' + episodes.Count.ToString + ' episodes for a match.');
      end;

      CodeSite.Send('Found ' + episodes.Count.ToString + ' episodes for series: ' + series.ToString);
      resultat  := TTVDBMatcher.Create(Fe, episodes);
//      resultat := matches;

    end;


    // Recheche GraceNote
    TGracenoteMatcher.Create(Fe,resultat);
//    matches := TGracenoteMatcher.Create(Fe,matches);
//    resultat := matches;


  finally
    ms.Free;
  end;


end;

function TTVDB.lookup: boolean;
var
  matches:   TMatchColl;
  series:    ITVDBSeries;
  tvdbMatch: ITVDBMatcher;
  ep:        ITVDBEpisode;
  dateStr:   string;
  m:         IMatch;
  bestMatch: IMatch;
  // unMatch: Match;
begin
//  matches := TInterfaceList.Create;
  matches := TMatchColl.Create;
  try

    for series in Fserieses do
    begin

      tvdbMatch := TTVDBMatcher.Create;
      try
        getMatches(series, tvdbMatch);

        if (tvdbMatch = nil) then
          continue;

        CodeSite.SendMsg(csmLevel7, 'TVDB Matches Found (title=' + Fe.getTitle + ', airdate=' +
          iif(Fe.hasOriginalAirDate, TTVGeneral.dateToTVDBString(Fe.getOriginalAirDate), 'unknown'));
        // FormatDateTime('yyyymmdd', Fe.getOriginalAirDate), 'unknown'));
        // CodeSite.SendMsg('originalAirDateMatches: ' + tvdbMatch.originalAirDateMatches.ToString);
        // CodeSite.SendMsg('exactTitleMatches:      ' + tvdbMatch.exactTitleMatches.ToString);
        // CodeSite.SendMsg('fuzzyTitleMatches:      ' + tvdbMatch.fuzzyTitleMatches.ToString);
        // CodeSite.SendMsg('containsTitleMatches:   ' + tvdbMatch.containsTitleMatches.ToString);

        // check air date + title matches
        if not(tvdbMatch.GetoriginalAirDateMatches.Count = 0) then // original airdate had some some matches
        begin
          // exact title & date
          if not(tvdbMatch.GetexactTitleMatches.Count = 0) then
          begin

            if (tvdbMatch.GetoriginalAirDateMatches.containsAll(tvdbMatch.GetexactTitleMatches)) then
            begin

              matches.add(TMatch.Create(TMatchAccuracy.ORIGINAL_AIR_DATE_AND_EXACT_TITLE, series,
                tvdbMatch.GetexactTitleMatches));
              break; // exact match, we can break now
            end;
          end;

          // fuzzytitle & date
          if (tvdbMatch.GetfuzzyTitleMatches.containsAll(tvdbMatch.GetoriginalAirDateMatches)) then
          begin

            matches.add(TMatch.Create(TMatchAccuracy.ORIGINAL_AIR_DATE_AND_FUZZY_TITLE, series,
              tvdbMatch.GetoriginalAirDateMatches));
            break; // exact (enough) match, we can break now
          end;

          // contains title & date
          if (tvdbMatch.GetcontainsTitleMatches.containsAll(tvdbMatch.GetoriginalAirDateMatches)) then
          begin

            matches.add(TMatch.Create(TMatchAccuracy.ORIGINAL_AIR_DATE_AND_CONTAINS_TITLE, series,
              tvdbMatch.GetoriginalAirDateMatches));
            continue; // check next series too since this isn't a very exact match
          end
          else // check in opposite direction. Catches if multiple episodes have same original air date, but needs to be filtered down to this episode
          begin
            if (tvdbMatch.GetcontainsTitleMatches.Count <> 0) then
            begin
              if (tvdbMatch.GetoriginalAirDateMatches.containsAll(tvdbMatch.GetcontainsTitleMatches)) then
              begin

                matches.add(TMatch.Create(TMatchAccuracy.ORIGINAL_AIR_DATE_AND_CONTAINS_TITLE, series,
                  tvdbMatch.GetcontainsTitleMatches));
                continue; // check next series too since this isn't very exact match
              end;
            end;
          end;

        end; // done with date combo matches


        // if we got here, there are no air date/combo matches. Check for title matches, but don't allow multi
        // part for those because we can't verify they aired on the same date.

        // exact title, solo match
        if (tvdbMatch.GetexactTitleMatches.Count = 1) then
        begin
          CodeSite.SendMsg(csmLevel7, 'Found Exact title match: ' + tvdbMatch.GetexactTitleMatches.ToString);
          matches.add(TMatch.Create(TMatchAccuracy.EXACT_TITLE, series, tvdbMatch.GetexactTitleMatches));
          break; // exact enough, break here
        end
        else if (tvdbMatch.GetexactTitleMatches.Count > 1) then
        begin
          CodeSite.SendWarning('Found ' + tvdbMatch.GetexactTitleMatches.Count.ToString +
            ' exact title matches! Don''t know what one to use!');
        end;

        // original airdate, solo/multi match
        if (tvdbMatch.GetoriginalAirDateMatches.Count <> 0) then
        begin
          // allow multi match for original air date
          matches.add(TMatch.Create(TMatchAccuracy.ORIGINAL_AIR_DATE, series, tvdbMatch.GetoriginalAirDateMatches));
          continue;
        end;

        // fuzzy title, solo match
        if (tvdbMatch.GetfuzzyTitleMatches.Count = 1) then
        begin
          matches.add(TMatch.Create(TMatchAccuracy.FUZZY_TITLE, series, tvdbMatch.GetfuzzyTitleMatches));
          continue;
        end
        else if (tvdbMatch.GetfuzzyTitleMatches.Count > 1) then
          CodeSite.SendMsg(csmLevel7, 'Found ' + tvdbMatch.GetfuzzyTitleMatches.Count.ToString +
            ' fuzzy title matches! Don''t know what one to use!');

        // contains title, solo match
        if (tvdbMatch.GetcontainsTitleMatches.Count = 1) then
        begin
          matches.add(TMatch.Create(TMatchAccuracy.CONTAINS_TITLE, series, tvdbMatch.GetcontainsTitleMatches));
          continue;
        end;

        // allow multi-contains if the air date is all the same
        if (tvdbMatch.GetcontainsTitleMatches.Count > 1) then
        begin
          CodeSite.SendMsg(csmLevel7,
            'Found multiple contains-title matches, determining if all have same original air date.');
          dateStr := ''; // = null;
          for ep in tvdbMatch.GetcontainsTitleMatches do
          begin
            if (ep.GetfirstAired = '') then
            begin // no valid date from tvdb... can't check this
              dateStr := '';
              break;
            end;

            if (dateStr = '') then
            begin
              dateStr := ep.GetfirstAired; // init
            end
            else if (not dateStr.equals(ep.GetfirstAired)) then
            begin
              dateStr := ''; // signals invalid because they dont all have the same date
              break;
            end;
          end;
          if (dateStr <> '') then // same date for all episodes
          begin
            CodeSite.SendMsg(csmLevel7,
              'All contains-title matches have same original air date, will add as a multi-part episode');
            matches.add(TMatch.Create(TMatchAccuracy.CONTAINS_TITLE, series, tvdbMatch.GetcontainsTitleMatches));
          end
          else
          begin
            CodeSite.SendMsg(csmLevel7,
              'Contains-title matches have different air-dates, cannot determine what episode to use.');
          end;
        end;

      finally
        if assigned(tvdbMatch) then
        begin
//           tvdbMatch:=nil;
//          tvdbMatch.Free;
        end;

      end;
    end; // end looping through all series and finding matches

    //REcherhe avec GraceNote
//     getMatches(series, tvdbMatch);


    if (matches.Count <> 0) then
    begin
      CodeSite.SendMsg(csmLevel7, 'Found ' + matches.Count.ToString + ' TVDB.com match' + iif(matches.Count = 1,
        ', will use it', 'es, will use best one'));
      matches.Sort; // best matches (most accurate) are on top now

      // print all matches
      for m in matches do
      begin
        CodeSite.SendMsg('Match - Series: ' + m.getSeries.ToString + ': ' + m.Getaccuracy.ToString + ' for ' +
          m.GetmatchingEpisodes.Count.ToString + ' episode(s):');

        // CodeSite.SendWarning(m.matchingEpisodes.ToString);
      end;

      // use the first (best) match
      bestMatch := matches[0];

      Fe.setSeries(bestMatch.getSeries);

      if (bestMatch.GetmatchingEpisodes.Count > 1) then // log if multiple episodes
      begin
        CodeSite.SendMsg(csmLevel7, 'Multi-Part: Setting matching episodes to: ' + bestMatch.GetmatchingEpisodes.ToString);
      end;

      Fe.setMatchingEpisodes(bestMatch.GetmatchingEpisodes);
      Result := true;
    end
    else
    begin
      if (Fe.hasRemoteId) then // maybe the remote id is wrong, try it based on series name
      begin
        CodeSite.SendMsg(csmLevel7,'No match was found using exernal id(s), will try lookup based on series name now.');
        Fe.clearRemoteIds();

        findMatchingSeries(Fserieses);

        Result := lookup(); // recurse using the new seriesIds
      end
      else // no match
      begin
        CodeSite.SendWarning('Found no matches!');
        Result := False;
      end;
    end;

  finally
    matches.Free;
     tvdbMatch:=nil;
  end;

end;

class function TTVGeneral.normalize(s: String): String;
var
  normal: string;
  I:      Integer;
  c:      char;
begin
  if (s = '') then
  begin
    Result := '';

  end
  else
  begin
    normal := '';
    for I  := 0 to s.length - 1 do
    begin
      c := s.Chars[I]; // s.charAt(i);
      if (c = '/') then
        begin
//        c := ' '; // replace slash with a space
          normal := normal + c;

        end
      else if not CharInSet(c, TTVGeneral.UNCOMMON_CHAR_ARRAY2) then //  not(c in UNCOMMON_CHAR_ARRAY2) then // noy uncommon
      begin
        normal := normal + c;
      end;
    end;
    Result := normal;
  end;
end;



{ TTVGracenote }

constructor TTVGracenote.Create(var e: IEpisode);
begin
  inherited Create;

  self.Fe := e;


  Fserieses := TTVDBSeriesColl.Create;

  if e = nil then
  begin
    raise Exception.Create('No episode found to look up.');
  end;

  if not e.hasSeries then
  begin

    raise Exception.Create('No series name found.');
  end;

  // get the series from tvdb based on series name and language
  findMatchingSeries(Fserieses); // populates seriesIds
  if (Fserieses.Count = 0) then
  begin
    // raise Exception.Create('No series found on TVDB.com for series name \' + e.getSeries.toString + '\');
  end;

end;

destructor TTVGracenote.Destroy;
begin

  inherited;
end;

procedure TTVGracenote.findMatchingSeries(out resultat: TTVDBSeriesColl);
begin

end;

function TTVGracenote.lookup: boolean;
begin

end;

end.
