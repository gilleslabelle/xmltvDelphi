{ ******************************************************* }
{ *
  {* uTVDBMatcher.pas
  {* Delphi Implementation of the Class TVDBMatcher
  {* Generated by Enterprise Architect
  {* Created on:      09-févr.-2015 11:44:25
  {* Original author: Labelleg
  {*
  {******************************************************* }

unit uTVDBMatcher;

interface

uses uEpisode, uTVDBEpisode, System.Generics.Collections, Xml.XMLIntf, uTVDBBind;

type

  TTVDBMatcher = class
  strict private
    FcontainsTitleMatches: TVDBEpisodeColl;
    FexactTitleMatches: TVDBEpisodeColl;
    FfuzzyTitleMatches: TVDBEpisodeColl;
    ForiginalAirDateMatches: TVDBEpisodeColl;
  private
    procedure SetcontainsTitleMatches(const Value: TVDBEpisodeColl);
    procedure SetexactTitleMatches(const Value: TVDBEpisodeColl);
    procedure SetfuzzyTitleMatches(const Value: TVDBEpisodeColl);
    procedure SetoriginalAirDateMatches(const Value: TVDBEpisodeColl);
  public
    constructor Create(guideEpisode: IEpisode; tvdbEpisodes: IXMLTVDBEpisodeTypeList);
    destructor Destroy; override;

    property containsTitleMatches: TVDBEpisodeColl read FcontainsTitleMatches write SetcontainsTitleMatches;
    property exactTitleMatches: TVDBEpisodeColl read FexactTitleMatches write SetexactTitleMatches;
    property fuzzyTitleMatches: TVDBEpisodeColl read FfuzzyTitleMatches write SetfuzzyTitleMatches;
    property originalAirDateMatches: TVDBEpisodeColl read ForiginalAirDateMatches write SetoriginalAirDateMatches;

  end;

implementation

uses Rest.Utils, uTVDB, System.Math, System.SysUtils;
{ implementation of TVDBMatcher }

constructor TTVDBMatcher.Create(guideEpisode: IEpisode; tvdbEpisodes: IXMLTVDBEpisodeTypeList);
var
  guideTitle: string;
  hasTitle: Boolean;
  epFirstAired: string;
  hasOriginalAirDate: Boolean;
  tvdbEp: IXMLTVDBEpisodeType;
  tvdbTitle: string;
  tvdbFirstAired: string;
  tvdbSeasonNumber: string;
  tvdbEpisodeNumber: string;
  hasTVDBImage: Boolean;
  i: Integer;
  tvdbEpisode: ITVDBEpisode;
  contains: Boolean;
  containsNormalized: Boolean;
begin

  FcontainsTitleMatches := TVDBEpisodeColl.Create;
  FexactTitleMatches := TVDBEpisodeColl.Create;
  FfuzzyTitleMatches := TVDBEpisodeColl.Create;
  ForiginalAirDateMatches := TVDBEpisodeColl.Create;

  {
    * exact title & original airdate (check for multipart?)
    * fuzzy title & original air date (check for multipart)
    * contains title & original air date (check for multipart)
    * exact title (must be a solo match)
    * original airdate (must be a solo match)
    * fuzzy title (must be a solo match)
    * contains title (must be a solo match)
  }

  // episode info
  guideTitle := guideEpisode.getTitle();
  hasTitle := guideEpisode.hasTitle();
  epFirstAired := iif(guideEpisode.hasOriginalAirDate(), TTVDB.dateToTVDBString(guideEpisode.getOriginalAirDate()), '');

  // String epFirstAired := guideEpisode.hasOriginalAirDate() ? dateToTVDBString(guideEpisode.getOriginalAirDate()) : null;
  hasOriginalAirDate := (epFirstAired <> '');

  if (not hasTitle and not hasOriginalAirDate) then
    exit; // return;//nothing to do!

  for i := 0 to tvdbEpisodes.Count - 1 do
  begin
    tvdbEp := tvdbEpisodes[i];

    tvdbTitle := tvdbEp.EpisodeName; // .getChildText(' EpisodeName ');
    tvdbFirstAired := tvdbEp.FirstAired; // getChildText(' FirstAired ');
    tvdbSeasonNumber := tvdbEp.SeasonNumber; // getChildText(' SeasonNumber ');
    tvdbEpisodeNumber := tvdbEp.EpisodeNumber; // getChildText(' EpisodeNumber ');
    hasTVDBImage := (tvdbEp.Filename <> ''); // getChildText(' filename '));
    // <filename> stores the path to the .jpg image for the episode
    // final TVDBEpisode TVDBEpisode := new TVDBEpisode(tvdbTitle, tvdbFirstAired, tvdbSeasonNumber, tvdbEpisodeNumber,    hasTVDBImage);
    tvdbEpisode := TTVDBEpisode.Create(tvdbTitle, tvdbFirstAired, tvdbSeasonNumber, tvdbEpisodeNumber, hasTVDBImage);

    if (hasTitle and (tvdbTitle <> '')) then
    begin
      // exact title matches (alwasy case-insensitive and special chars removed (normalized))
      if SameText(TTVDB.normalize(guideTitle), TTVDB.normalize(tvdbTitle)) then
      begin
        exactTitleMatches.add(tvdbEpisode);
      end
      else // not exact title match, check for fuzzy and contains
      begin
        if (TTVDB.fuzzyTitleMatch(guideTitle, tvdbTitle, 15)) then
          // allow 15 percent discrepency)
          fuzzyTitleMatches.add(tvdbEpisode);

        // check for contains (the program guide title contains the tvdb title)
        contains := guideTitle.ToLower.contains(tvdbTitle.ToLower);
        containsNormalized := TTVDB.normalize(guideTitle).ToLower.contains(TTVDB.normalize(tvdbTitle).ToLower);
        if (contains or containsNormalized) then
          containsTitleMatches.add(tvdbEpisode);
      end;
    end;

    if (hasOriginalAirDate) then
    begin
      if SameText(epFirstAired, tvdbFirstAired) then
        originalAirDateMatches.add(tvdbEpisode);
    end;
  end;

end;

destructor TTVDBMatcher.Destroy;
begin
  FcontainsTitleMatches.free;
    FexactTitleMatches.free;
    FfuzzyTitleMatches.free;
    ForiginalAirDateMatches.free;


  inherited Destroy;
end;

procedure TTVDBMatcher.SetcontainsTitleMatches(const Value: TVDBEpisodeColl);
begin
  FcontainsTitleMatches := Value;
end;

procedure TTVDBMatcher.SetexactTitleMatches(const Value: TVDBEpisodeColl);
begin
  FexactTitleMatches := Value;
end;

procedure TTVDBMatcher.SetfuzzyTitleMatches(const Value: TVDBEpisodeColl);
begin
  FfuzzyTitleMatches := Value;
end;

procedure TTVDBMatcher.SetoriginalAirDateMatches(const Value: TVDBEpisodeColl);
begin
  ForiginalAirDateMatches := Value;
end;

end.
