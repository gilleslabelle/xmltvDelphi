{ ******************************************************* }
{ *
  {* uSeriesTracker.pas
  {* Delphi Implementation of the Class SeriesTracker
  {* Generated by Enterprise Architect
  {* Created on:      09-févr.-2015 11:42:14
  {* Original author: Labelleg      OK
  {*
  {******************************************************* }

unit xmltvdb.SeriesTracker;

interface

uses
  System.Generics.Collections, System.Classes;

type

  ISeriesTracker = Interface
    procedure addFail;
    procedure addSuccess;
    // order more successful first

//    function CompareTo(Other: ISeriesTracker): Integer;

    function getFail: Integer;
    function getPercentSuccessful: double;
    function getSeries: String;
    function getSucess: Integer;
    function getTotal: Integer;
  end;



  TSeriesTracker = class(TInterfacedObject, ISeriesTracker)
  strict private
    Ffail: Integer;
    Fseries: String;
    Fsucess: Integer;
  public
    procedure addFail;
    procedure addSuccess;
    // order more successful first

//    function CompareTo(Other: TSeriesTracker): Integer;

    function getFail: Integer;
    function getPercentSuccessful: double;
    function getSeries: String;
    function getSucess: Integer;
    function getTotal: Integer;
    constructor Create(series: String);

    destructor Destroy; override;
  end;

  TSeriesTrackerHashColl = Class(TObjectDictionary<string, ISeriesTracker>)
  public
    constructor Create();
    destructor Destroy; override;
    function Get(const lestring:string):ISeriesTracker  ;
    function IsExist(const lestring:string):Boolean;

//    procedure Sort; overload;

  End;

 ISeriesTrackerColl = interface(IInterfaceListEx)  ['{32A73DA8-E34C-4D4C-ABD6-CBCF22B0B59D}']
    function Add(const lestring:string;const obj : ISeriesTracker) : integer;
    function Get(const lestring:string):ISeriesTracker  ;
    function IsExist(const lestring:string):Boolean;
  end;


//  TSeriesTrackerHashColl = Class(TInterfaceList, ISeriesTrackerColl)
//  strict private
//   FDict : TDictionary<string , ISeriesTracker>;
//  public
//    constructor Create();
//    destructor Destroy; override;
//
//    function Add(const lestring:string;const obj : ISeriesTracker) : integer;
//    function Get(const lestring:string):ISeriesTracker  ;
//    function IsExist(const lestring:string):Boolean;
//
//  End;


  TSeriesTrackerColl = class(TList<ISeriesTracker>)
  public
     procedure Sort; overload;
  end;


implementation

uses
  System.Generics.Defaults;


procedure TSeriesTracker.addFail;
begin
  inc(Ffail);
end;

procedure TSeriesTracker.addSuccess;
begin
  inc(Fsucess);
end;

//function TSeriesTracker.CompareTo(Other: TSeriesTracker): Integer;
//begin
//
//
//  if Self.getPercentSuccessful > Other.getPercentSuccessful then
//  begin
//    Result := -1;
//  end
//  else if Self.getPercentSuccessful < Other.getPercentSuccessful then
//  begin
//    Result := 1
//  end
//  else
//  begin
//    Result := 0;
//  end;
//
//end;

constructor TSeriesTracker.Create(series: String);
begin
  inherited Create;
  Ffail := 0;
  Fsucess := 0;

  Self.Fseries := series;
end;

destructor TSeriesTracker.Destroy;
begin

  inherited Destroy;
end;

function TSeriesTracker.getFail: Integer;
begin
  Result := Ffail;
end;

function TSeriesTracker.getPercentSuccessful: double;
begin
  if Self.getTotal = 0 then
  begin

    Result := 0
  end
  else
  begin
    Result := 100.0 * (getSucess() / getTotal());
  end;
end;

function TSeriesTracker.getSeries: String;
begin
  Result := Fseries;
end;

function TSeriesTracker.getSucess: Integer;
begin
  Result := Fsucess;
end;

function TSeriesTracker.getTotal: Integer;
begin
  Result := getSucess + getFail;
end;

{ TSeriesTracker }

{ TSeriesTrackerColl }
//function TSeriesTrackerHashColl.Add(const lestring:string;const obj : ISeriesTracker) : integer;
//begin
//   Result := inherited Add(obj);
//   FDict.Add(lestring,obj);
//end;

//constructor TSeriesTrackerHashColl.Create;
//begin
////  inherited Create([doOwnsValues]);
//  inherited Create;
//
//     FDict := TDictionary<string , ISeriesTracker>.Create ;
//
//end;

//destructor TSeriesTrackerHashColl.Destroy;
//begin
//    FDict.Free;
//  inherited;
//end;

//function TSeriesTrackerHashColl.Get(const lestring:string): ISeriesTracker;
//begin
//      Result := FDict[lestring];
//end;
//
//function TSeriesTrackerHashColl.IsExist(const lestring: string): Boolean;
//begin
//    Result := FDict.ContainsKey(lestring);
//end;


{ TSeriesTrackerColl }

procedure TSeriesTrackerColl.Sort;
begin


    Self.Sort( TComparer<ISeriesTracker>.Construct(
      function(const Item1,Item2:ISeriesTracker): Integer
      begin
//         Result :=  1;//CompareValue( Ord( Item1.Getaccuracy) ,Ord(Item2.Getaccuracy));
          if Item1.getPercentSuccessful > Item2.getPercentSuccessful then
            begin
              Result := -1;
            end
            else if Item1.getPercentSuccessful < Item2.getPercentSuccessful then
            begin
              Result := 1
            end
            else
            begin
              Result := 0;
            end;

      end));




end;

{ TSeriesTrackerHashColl }

constructor TSeriesTrackerHashColl.Create;
begin
//    inherited Create([doOwnsValues]);
   inherited Create;
end;

destructor TSeriesTrackerHashColl.Destroy;
begin

  inherited destroy;
end;

function TSeriesTrackerHashColl.Get(const lestring: string): ISeriesTracker;
begin
      Result := Self[lestring];
end;

function TSeriesTrackerHashColl.IsExist(const lestring: string): Boolean;
begin
     Result:= Self.ContainsKey(lestring);
end;

end.
